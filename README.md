Решение тестового задания №3
===============
В памяти есть 10 000 000 объектов со следующими полями:
 
1) возраст (0..100)
2) зарплата (0..1000000,0)
3) рост (0..200)
4) вес (0..200)
 
Нужно написать максимально быстрый алгоритм для выбора объектов по определённым условиям (условий может быть от 0 до 4, в качестве условия можно указать диапазон значений)


Описание логики:
За основную структуру данных берем двоичное дерево поиска, т.к. необходимо реализовать логику поиска не только точного совпадения, но и условий < >. В случае поиска точного совпадения разумнее было бы использовать хеш-таблицу.

В данный момент дерево не сбалансировано, но предполагаем, что, к примеру, методом "красное-черное" можно его сбалансировать и гарантировать логорифмический рост его высоты. Поэтому предполагаем логорифмическую сложность операции поиска O(lg)

Поскольку необходима логика реализации составных условий, приходим к объединению результатов на основе хеш-таблиц за время O(m) - O(m+l), где m, l - кол-во элеметов во множествах результатов.
Т.к. по условниям задачи необходимо реализовать логику условния in (..) использовать R-деревья ("многомерные" деревья) не разумно, т.к. проблема с объединением результатов все равно остается.

При более конкретных условиям вместо двоичного дерево возможно использовать B-дерево, которое позволит уменьшить высоту дерева поиска, но по факту сложность остается логорифмической (с другим основанием логорифма)

Результат:
В лучшем случае поиск идет за время O(lg n) (поиск по одному условию: ==, >, <)
В худшем случае (составное условие, или in) к логорифмической сложности имеем небольшую линейную зависимость от длинны результатов поиска по каждому из условий. В этом случае необходимо задумываться о корректном написании запросов и иметь представление о возможных значениях в таблице данных.
Небольшую оптимизацию можно произвести в плане порядка объединения результатов условий исходя из размера.

См. тест person_manager_spec с примерами работы кода для поиска персон.
